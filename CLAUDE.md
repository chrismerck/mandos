# Mandos2 - Middle Earth Terminal Map Game

## Purpose
ADOM-inspired roguelike terminal game for exploring a Middle Earth ASCII map using React Ink and TypeScript with an Entity Component System (ECS) architecture.

## Architecture

### ECS Core (`src/ecs/`)
- **Entity.ts**: Container with unique ID holding components via Map<string, Component>
- **Component.ts**: Interface with `type: string` property
- **System.ts**: Abstract class with `update(world: World, deltaTime: number)` method
- **World.ts**: Manages entities, runs systems, provides `getEntitiesWithComponent()`

### Components (`src/components/`)
- **Position.ts**: `x: number, y: number` - world coordinates
- **Renderable.ts**: `char: string, priority: number, color?: Color` - visual representation
- **Movable.ts**: `speed: number` - movement capability
- **Player.ts**: Tag component to identify player entity

### Systems (`src/systems/`)
- **InputSystem.ts**: Captures keyboard input, stores current Direction
- **MovementSystem.ts**: Updates Position based on InputSystem direction, checks collision
- **ViewportSystem.ts**: Maintains 80x20 view centered on player
- **RenderSystem.ts**: Creates StyledTile[][] combining map + entities
- **TerrainColors.ts**: Color mappings for terrain types

### Map Data
- **MapData.ts**: Loads `maps/middle_earth.worldmap`, provides `getTile()` and `getViewport()`
- Terrain types: `=` ocean, `-|` rivers, `^` mountains, `&` forests, `.` roads, `o` towns
- Collision detection in MovementSystem: Can't walk on `=`, `~`, `^`

### UI Components
- **Game.tsx**: Main game loop, creates player entity, manages systems
- **MapDisplay.tsx**: Renders StyledTile[][] with Text components, groups by style
- **index.tsx**: Entry point, sets up ink render()
- **hooks/useInputSystem.ts**: React hook connecting ink's useInput to InputSystem

### Key Patterns
- All imports use `.js` extensions (ESM modules)
- Systems execute order: Input → Movement → Viewport → Render  
- Player entity has: Position(50,50), Renderable('@', 10, 'yellowBright'), Movable(1), Player()
- Tests in `__tests__` folders use Jest with ts-jest

### Commands
```bash
npm test     # Run tests
npm start    # Run game (requires TTY)
npm build    # TypeScript compilation
npm run preprocess-map  # Regenerate region data from map
```

## Development Notes

### TypeScript Configuration
- Uses `"moduleResolution": "bundler"` for compatibility with ink v6
- ESM modules with `.js` extensions in imports (even for .ts files)
- Strict mode enabled

### Dependencies
- **ink v6**: Terminal UI framework (provides own TypeScript types, no @types/ink needed)
- **React 19**: Used by ink for component model
- **tsx**: For running TypeScript directly without compilation

### Region System
- **RegionData.ts**: Loads preprocessed binary region grid (maps/middle_earth_regions.bin)
- **RegionInfo.ts**: Component tracking current realm/sub-region names
- **RegionDisplaySystem.ts**: Updates region info based on player position
- Python preprocessing script in `scripts/map_preprocessing.py` generates region data
- Binary format REG2: 4-byte header + 3 bytes per tile (realm ID, sub-region ID, geo feature ID) + name tables
- Geographic features (mountains, forests, etc.) take display priority over regions

### Geographic Features
- **geo_features_preprocessing.py**: Module for detecting and labeling geographic features
- Supports embedded labels (e.g., "Mirkwood") and ?-prefixed labels (e.g., "?Dead_Marshes")
- Features can span multiple realms (e.g., Misty Mountains)
- Rivers and roads don't break feature connectivity
- 48 geographic features detected in Middle Earth map

### Build Process
- `npm run prebuild` automatically runs map preprocessing
- Generates ~200KB binary grid + POI CSV from 100KB ASCII map
- Region lookups are O(1) using direct array indexing

### Testing Considerations
- Game requires TTY for input (won't work in non-interactive environments)
- Use `npm run dev` for development with hot reload via tsx
- Region data files must exist before running (generated by preprocessing)

### Code Style
- No comments unless explicitly requested
- Prefer editing existing files over creating new ones
- Follow existing patterns for components/systems
- Use component composition for UI (Box, Text from ink)